# -*- coding: utf-8 -*-
"""SCL WS-1

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1R8KBbYXI1qnDoqdoOMS5Pbue012iE5Zj
"""

'''
1. Write a python program to find augmented matrix corresponding to
the following linear system. Also print the given linear system with its
augmented matrix.
'''
import numpy as np

row=int(input("Enter the number of rows :"))
col=int(input("Enter the number of columns :"))

coeff=list(map(int,input().split()))
coeff_mat=np.array(coeff).reshape(row,col)


const=list(map(int,input("Enter the constants : ").split()))
const_mat=np.array(const).reshape(row,1)

print(coeff_mat,"\n")
print(const_mat,"\n")

aug_mat=np.hstack((coeff_mat,const_mat))
print(aug_mat,"\n")

import numpy as np

def check(matrix):
    num_rows = len(matrix)
    num_cols = len(matrix[0])
    indices = set()

    for i in range(num_rows):
        temp = False
        for j in range(num_cols):
            if matrix[i][j] != 0:
                if j in indices:
                    return False
                if matrix[i][j] == 1:
                    temp = True
                    indices.add(j)
                    break
                else:
                    return False
        if not temp and i != num_rows - 1:
            return False
    return True


row=int(input("Enter the number of rows :"))
col=int(input("Enter the number of columns :"))
coeff=list(map(int,input().split()))
matrix=np.array(coeff).reshape(row,col)
for i in range(row):
  for j in range(col):
    print(matrix[i][j],end=" ")
  print()
print(check(matrix))

import numpy as np

rows=int(input("Enter the number of rows :"))
coln=int(input("Enter the number of columns :"))

coeff=list(map(int,input().split()))
mat=np.array(coeff).reshape(rows,coln)

for i in range(0,rows):
    pivot=mat[i][i]

    if(pivot==0):
        print("singular matrix")
        break
    mat[i]=mat[i]/pivot

    for j in range(0,rows):
        if(j!=i):
            mat[j]=mat[j]-mat[j][i]*mat[i]


print(mat)

rank=0
for i in mat:
    flag = 0
    for j in i:
        if j!=0:
            flag = 1
            break
    if flag == 1:
        rank=rank+1
print("Rank : ",rank)

import numpy as np

rows=int(input("Enter the number of rows :"))
coln=int(input("Enter the number of columns :"))

coeff=list(map(int,input().split()))
mat=np.array(coeff).reshape(rows,coln)

for i in range(0,rows):
    pivot=mat[i][i]

    if(pivot==0):
        print("singular mat")
        break
    mat[i]=mat[i]/pivot

    for j in range(0,rows):
        if(j!=i):
            mat[j]=mat[j]-mat[j][i]*mat[i]

print(mat)


aug_rank=0
for i in mat:
    flag = 0
    for j in i:
        if j!=0:
            flag = 1
            break
    if flag == 1:
        aug_rank=aug_rank+1


rank=0
mat1 =  mat[0:rows, 0:coln-1]
for i in mat1:
    flag = 0
    for j in i:
        if j!=0:
            flag = 1
            break
    if flag == 1:
        rank=rank+1

print("Rank : ",rank)
print("Aug_Rank : ",aug_rank)

if aug_rank==rank and rank==rows:
    print("Unique solution")
    print("Solutions:")
    for i in range(rows):
        print(mat[i][coln-1])

elif aug_rank>rank:
    print("No solution")

else:
    print("infinite solution")

import numpy as np


a=np.array([[4,1,1],[1,5,2],[1,2,3]])
b=np.array([2,-6,-4])
print(a)
rows=a.shape[0]
cols=a.shape[1]
A=a
B=b
x_i=np.array([0,0,0])

def gauss_jacobi(A,B,x_i):
    x=x_i
    for i in range(100):
        d=np.diag(A)
        R=A-np.diag(d)
        x=(B-np.dot(R,x_i))/d
        if np.allclose(x, x_i, rtol=0, atol=0.0001):
            break
        x_i=x
    return np.round(x,4)

indexes=[]
for i in range(0,rows):
    m=max(a[i])
    x=0
    diff=2*max(a[i])-sum(a[i])
    if diff>=0:
        x=np.argwhere(a[i]==m)
        indexes.append(x[0][0])

order=1
if len(np.unique(indexes))==len(indexes):
    for i in range(len(indexes)):
        if indexes[i]!=i:
            order=0
            break
    if order==1:
        print('diagonally dominant already')
        y=gauss_jacobi(A,B,x_i)
        print(y)

    else:
        for i in range(len(indexes)):
            A[indexes[i]]=a[i]
            B[indexes[i]]=b[i]
        print('diagonally dominant after rearranging')
        print(A)
        print(B)
else:
    print('the matrix is not diagonally dominant')

import numpy as np


a=np.array([[4,1,1],[1,5,2],[1,2,3]])
b=np.array([2,-6,-4])
print(a)
rows=a.shape[0]
cols=a.shape[1]
A=a
B=b
x_i=np.array([0,0,0])

def gauss_seidel(A, b, x0, tol=0.01, max_iter=100):
    n = len(A)
    x = x0.copy()
    for k in range(max_iter):
        for i in range(n):
            s = sum(A[i][j]*x[j] for j in range(n) if j != i)
            x[i] = (b[i] - s) / A[i][i]
        print(f'Iteration {k + 1}: {x}')
        if all(abs(x[i] - x0[i]) < tol for i in range(n)):
            return x
        x0 = x.copy()
    raise ValueError('no convergence')

indexes=[]
for i in range(0,rows):
    m=max(a[i])
    x=0
    diff=2*max(a[i])-sum(a[i])
    if diff>=0:
        x=np.argwhere(a[i]==m)
        indexes.append(x[0][0])

order=1
if len(np.unique(indexes))==len(indexes):
    for i in range(len(indexes)):
        if indexes[i]!=i:
            order=0
            break
    if order==1:
        print('diagonally dominant already')
        y=gauss_seidel(A,B,x_i)
        print(y)
    else:
        for i in range(len(indexes)):
            A[indexes[i]]=a[i]
            B[indexes[i]]=b[i]
        print('diagonally dominant after rearranging')
        print(A)
        print(B)
else:
    print('the matrix is not diagonally dominant')

import numpy as np
import sympy as sp

#(i)
print("")
A = np.array([[1, 2, -1], [2, 3, -1], [1, 1, -1]])
B = np.array([4, 7, 3])
x = np.linalg.solve(A, B)
print("\nSolution using numpy.linalg.solve() : ", x)

#(ii)
print("\nInverse")
A_inv = np.linalg.inv(A)
print("Inverse of A using numpy.linalg.inv() : ")
print(A_inv)

#(iii)
print("\nMultiplication")
C = np.array([[1, 2], [3, 4], [5, 6]])
D = np.array([[7, 8], [9, 10]])
E = np.dot(C, D)
print("Matrix multiplication using numpy.dot() : ")
print(E)

#(iv)
print("\nSympy's linsolve")
a, b, c, x, y, z = sp.symbols('a b c x y z')
eq1 = sp.Eq(a*x + b*y + c*z, 4)
eq2 = sp.Eq(2*a*x + 3*b*y - c*z, 7)
eq3 = sp.Eq(x + y - z, 3)
sol = sp.linsolve([eq1, eq2, eq3], (x, y, z))
print("Solution using sympy.linsolve():\n", sol)

'''
gauss jacobi
'''

import numpy as np

def gauss_jacobi(aug_mat,no_of_var,sol):
    temp= [0]*no_of_var
    for i in range(0,no_of_var):
        b=aug_mat[i][no_of_var]
        for j in range(0,no_of_var):
            if i!=j:
                b-=aug_mat[i][j]*sol[j]
        temp[i]=b/aug_mat[i][i]
    sol=temp
    return sol



no_of_equation = int(input("Enter no of eqs:"))
no_of_var = int(input("Enter no of vars:"))
co_eff = list(map(int,input().split()))

aug_mat = np.array(co_eff).reshape(no_of_equation, no_of_var+1)

li=[]

for i in range(0,no_of_equation):
    if sum(abs(aug_mat[i,0:no_of_var])) <= 2*max(aug_mat[i,0:no_of_var]):
        index = np.argwhere(aug_mat[i,0:no_of_var]==max(aug_mat[i,0:no_of_var]))
        x=index[0][0]
        li.append(x)

check_set = set(li)
li1 = [ i for i in range(0,no_of_var)]

if len(li) > len(check_set):
    print("It is not a diagonally dominant matrix")
else:
    if li == list(check_set):
        print("It is diagonlly dominant matrix")
    else:
        print("It is not a diagonally dominant but can be changed ")
        aug_mat[li ,:]=aug_mat[li1, :]
        print(aug_mat)

sol=[0]*no_of_var
print(sol)

for i in range(0,10):
    sol=gauss_jacobi(aug_mat,no_of_var,sol)
    print(sol)

'''
gauss seidal
'''

import numpy as np

def gauss_seidal(aug_mat,no_of_var,sol):
    for i in range(0,no_of_var):
        b=aug_mat[i][no_of_var]
        for j in range(0,no_of_var):
            if i!=j:
                b-=aug_mat[i][j]*sol[j]
        sol[i]=b/aug_mat[i][i]



no_of_equation = int(input("Enter no of eqts:"))
no_of_var = int(input("Enter no of vars:"))
co_eff = list(map(int,input().split()))
aug_mat = np.array(co_eff).reshape(no_of_equation, no_of_var+1)

li=[]

for i in range(0,no_of_equation):
    if sum(abs(aug_mat[i,0:no_of_var])) <= 2*max(aug_mat[i,0:no_of_var]):
        index = np.argwhere(aug_mat[i,0:no_of_var]==max(aug_mat[i,0:no_of_var]))
        x=index[0][0]
        li.append(x)



check_set = set(li)
li1 = [ i for i in range(0,no_of_var)]

if len(li) > len(check_set):
    print("It is not a diagonally dominant matrix")
else:
    if li == list(check_set):
        print("It is diagonlly dominant matrix")
    else:
        print("It is not a diagonally dominant but can be changed ")
        aug_mat[li ,:]=aug_mat[li1, :]
        print(aug_mat)

sol=[0]*no_of_var
print(sol)

for i in range(0,10):
    gauss_seidal(aug_mat,no_of_var,sol)
    print(sol)

def row_echelon(matrix):
    pivot_col = 0
    num_rows = len(matrix)
    num_cols = len(matrix[0])
    for r in range(num_rows):
        if pivot_col >= num_cols:
            return matrix
        i = r
        while matrix[i][pivot_col] == 0:
            i += 1
            if i == num_rows:
                i = r
                pivot_col += 1
                if num_cols == pivot_col:
                    return matrix
        matrix[i], matrix[r] = matrix[r], matrix[i]
        pivot_val = matrix[r][pivot_col]
        matrix[r] = [int(mrx / float(pivot_val)) for mrx in matrix[r]]
        for i in range(r+1, num_rows):
            pivot_val = matrix[i][pivot_col]
            matrix[i] = [int(iv - pivot_val*rv) for rv, iv in zip(matrix[r], matrix[i])]
        pivot_col += 1
    return matrix

# Example matrix
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

# Print original matrix
print("Original matrix:")
for row in matrix:
    print(row)

# Compute row echelon form
row_echelon_form = row_echelon(matrix)

# Print row echelon form
print("Row echelon form:")
for row in row_echelon_form:
    print(row)

def is_row_echelon(matrix):
    num_rows = len(matrix)
    num_cols = len(matrix[0])
    prev_pivot = -1
    for r in range(num_rows):
        pivot_found = False
        for c in range(num_cols):
            if matrix[r][c] != 0:
                if c <= prev_pivot:
                    return False
                pivot_found = True
                prev_pivot = c
                break
        if not pivot_found and r != num_rows - 1:
            return False
    return True

# Example matrix
matrix = [[1,2,3], [0,1,2], [0,0,0]]

# Print original matrix
print("Original matrix:")
for row in matrix:
    print(row)

# Check if matrix is in row echelon form
if is_row_echelon(matrix):
    print("Matrix is in row echelon form")
else:
    print("Matrix is not in row echelon form")