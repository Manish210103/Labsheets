# -*- coding: utf-8 -*-
"""SCL ws-2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Sor-YtRBJfLtoM_ULVnQNEQRthPTnIru
"""

"""
  qn1
"""

import numpy as np
import sympy as sp


num=int(input("Enter the n value for nxn matrix : "))
print("Enter the ",num*num, " values : ")

mat = list(map(int,input().split()))
matrix=np.array(mat).reshape(num,num)


matrix1=sp.Matrix(matrix)
ident=np.eye(num)
lamda=sp.Symbol("l")


fin_mat=sp.Matrix(matrix1-lamda*ident)


fin_mat=fin_mat.det()
sols=sp.solve(fin_mat,lamda)
print("\nEigen Value : ")
print(sols)

evalue, evect = np.linalg.eig(matrix)
print("\n\nEigen Values : \n",evalue)
print("\n\nEigen vectors : \n",evect)

"""
    2. Write a python program to diagonalize the following matrix.
"""

import numpy as np
import sympy as sp

num = int(input("Enter the n value for nxn matrix: "))
print("Enter the", num * num, "values separated by spaces:")

# Read the matrix from the user input
mat = list(map(int, input().split()))
matrix = np.array(mat).reshape(num, num)

matrix1 = sp.Matrix(matrix)
ident = sp.eye(num)
lamda = sp.Symbol("l")

# Calculate the characteristic polynomial and find eigenvalues
fin_mat = sp.Matrix(matrix1 - lamda * ident)
fin_mat = fin_mat.det()
sols = sp.solve(fin_mat, lamda)
eigenvalues = [float(sol) for sol in sols]

# Eigenvalues and eigenvectors
eigenvalues, eigenvectors = np.linalg.eig(matrix)

# Diagonal matrix D
D = np.diag(eigenvalues)

# Eigenvector matrix P
P = eigenvectors

# Inverse of eigenvector matrix P^(-1)
P_inv = np.linalg.inv(P)

# Diagonalized matrix
diagonalized_mat = np.dot(np.dot(P, D), P_inv)

print("Original Matrix:")
print(matrix)

print("\nDiagonalized Matrix:")
print(diagonalized_mat)

"""
    3 . Write a python program to change the following quadratic form into
        canonical form
"""

import numpy as np
import sympy as sp
num=int(input("Enter the number of variables : "))
print("Enter the ",num*num, " coefficients : ")

mat = list(map(int,input().split()))
matrix=np.array(mat).reshape(num,num)



matrix1=sp.Matrix(matrix)
ident=np.eye(num)
lamda=sp.Symbol("l")


fin_mat=sp.Matrix(matrix1-lamda*ident)


fin_mat=fin_mat.det()
sols=sp.solve(fin_mat,lamda)

k=0
eigen_matrix=np.eye(num)
for i in range(num):
  for j in range(num):
    if i==j:
      eigen_matrix[i][j]=sols[k]
      k+=1
print("\n\n Canonical Form : ")
print(eigen_matrix)

"""
    4.  Check whether the following matrices are diagonalizable or not using
        python program.
"""

import numpy as np
import sympy as sp

num = int(input("Enter the n value for nxn matrix: "))
print("Enter the", num * num, "values separated by spaces:")

# Read the matrix from the user input
mat = list(map(int, input().split()))
matrix = np.array(mat).reshape(num, num)

matrix1 = sp.Matrix(matrix)
ident = sp.eye(num)
lamda = sp.Symbol("l")

# Calculate the characteristic polynomial and find eigenvalues
fin_mat = sp.Matrix(matrix1 - lamda * ident)
fin_mat = fin_mat.det()
sols = sp.solve(fin_mat, lamda)
eigenvalues = [float(sol) for sol in sols]

# Eigenvalues and eigenvectors
eigenvalues, eigenvectors = np.linalg.eig(matrix)

# Diagonal matrix D
D = np.diag(eigenvalues)

# Eigenvector matrix P
P = eigenvectors

# Inverse of eigenvector matrix P^(-1)
P_inv = np.linalg.inv(P)

# Diagonalized matrix
diagonalized_mat = np.dot(np.dot(P, D), P_inv)

print("Original Matrix:")
print(matrix)

print("\nDiagonalized Matrix:")
print(diagonalized_mat)


is_diagonal = np.all(matrix == np.diag(np.diagonal(matrix)))
print("Is the matrix diagonal?", is_diagonal)

"""
    5.  Write a python program for the following matrices to find the dominant
        eigen vector using power method and dominant eigen value using
        Rayleigh quotient?
"""

import numpy as np

def power_method(matrix, tolerance=1e-6, max_iterations=1000):
    n = matrix.shape[0]
    x = np.random.rand(n)
    x = x / np.linalg.norm(x)  # Normalize the initial vector

    for _ in range(max_iterations):
        prev_x = x
        x = np.dot(matrix, x)
        x = x / np.linalg.norm(x)  # Normalize the vector in each iteration

        # Check for convergence
        if np.linalg.norm(x - prev_x) < tolerance:
            break

    dominant_eigenvalue = np.dot(x, np.dot(matrix, x))
    dominant_eigenvector = x
    return dominant_eigenvalue, dominant_eigenvector

def rayleigh_quotient(matrix, eigenvector):
    numerator = np.dot(eigenvector, np.dot(matrix, eigenvector))
    denominator = np.dot(eigenvector, eigenvector)
    return numerator / denominator

# Example usage:
matrix = np.array([[2, -12], [1, -5]])

# Using Power Method
dominant_eigenvalue_pm, dominant_eigenvector_pm = power_method(matrix)
print("Dominant Eigenvalue (Power Method):", dominant_eigenvalue_pm)
print("Dominant Eigenvector (Power Method):", dominant_eigenvector_pm)

# Using Rayleigh Quotient
dominant_eigenvalue_rq = rayleigh_quotient(matrix, dominant_eigenvector_pm)
print("Dominant Eigenvalue (Rayleigh Quotient):", dominant_eigenvalue_rq)

"""
  qn6
"""
import numpy as np

def inverse_power_method(matrix, tolerance=1e-6, max_iterations=1000):
    n = matrix.shape[0]
    x = np.random.rand(n)
    x = x / np.linalg.norm(x)

    for _ in range(max_iterations):
        prev_x = x
        x = np.linalg.solve(matrix, x)
        x = x / np.linalg.norm(x)

        if np.linalg.norm(x - prev_x) < tolerance:
            break

    smallest_eigenvalue = 1 / np.dot(x, np.dot(matrix, x))
    smallest_eigenvector = x
    return smallest_eigenvalue, smallest_eigenvector

def rayleigh_quotient(matrix, eigenvector):
    numerator = np.dot(eigenvector, np.dot(matrix, eigenvector))
    denominator = np.dot(eigenvector, eigenvector)
    return numerator / denominator

# Example usage:
matrix = np.array([[4, -1], [2, 1]])

# Using Inverse Power Method
smallest_eigenvalue_ipm, smallest_eigenvector_ipm = inverse_power_method(matrix)
print("Smallest Eigenvalue (Inverse Power Method):", smallest_eigenvalue_ipm)
print("Smallest Eigenvector (Inverse Power Method):", smallest_eigenvector_ipm)

# Using Rayleigh Quotient
smallest_eigenvalue_rq = rayleigh_quotient(matrix, smallest_eigenvector_ipm)
print("Smallest Eigenvalue (Rayleigh Quotient):", smallest_eigenvalue_rq)

import numpy as np

def print_matrix(matrix):
    for row in matrix:
        print(row)
    print()

matrix_a = np.array([
    [1, 2, 0, 3, 1],
    [0, 0, 1, 1, 0],
    [0, 0, 0, 0, 1],
    [0, 0, 0, 0, 0]
])

print("Given Matrix:")
print_matrix(matrix_a)

# Use numpy's RREF function
rref_matrix = np.linalg.matrix_rank(matrix_a, tol=None)
ref_matrix = np.linalg.matrix_rank(matrix_a, tol=1e-10)
print(ref_matrix)
print(rref_matrix)
print(ref_matrix+1)
if rref_matrix == ref_matrix:
    print("The given matrix is in Reduced Row Echelon Form (RREF) and Row Echelon Form (REF).")
elif rref_matrix == ref_matrix + 1:
    print("The given matrix is in Row Echelon Form (REF), but not in RREF.")
else:
    print("The given matrix is not in REF or RREF.")

import numpy as np

def row_echelon_form(matrix):
    rows, cols = matrix.shape
    for i in range(rows):
        if matrix[i, i] == 0:
            nonzero_row = np.argmax(matrix[i:, i]) + i
            matrix[i], matrix[nonzero_row] = matrix[nonzero_row], matrix[i]
        matrix[i] /= matrix[i, i]
        matrix[i+1:] -= matrix[i+1:, i:i+1] * matrix[i]

# Get user input for matrix dimensions
row, col = map(int, input("Enter the number of rows and columns (space-separated): ").split())

# Get user input for matrix elements
elements = list(map(float, input("Enter the elements separated by spaces: ").split()))
matrix = np.array(elements).reshape(row, col)

print("Original Matrix:")
print(matrix)

# Compute row echelon form
row_echelon_form(matrix)

print("\nRow Echelon Form:")
print(matrix)

import numpy as np
from sympy import *

def find_canonical_form(vars, coeff_matrix):
    if vars == 2:
        vector = [x, y]
        X1 = np.array(vector).reshape(1, 2)
        X2 = np.array(vector).reshape(2, 1)
    elif vars == 3:
        vector = [x, y, z]
        X1 = np.array(vector).reshape(1, 3)
        X2 = np.array(vector).reshape(3, 1)

    eigen_value = coeff_matrix.eigenvals()
    eigen_vector = coeff_matrix.eigenvects()

    # Extracting the eigen vectors alone
    vecs = [eig[2][0] for eig in eigen_vector]

    # Finding norm
    norms = [vec.norm() for vec in vecs]

    normalized_vectors = []
    j = 0
    for vec in vecs:
        a = []
        for i in vec:
            a.append(i / norms[j])
        j += 1
        normalized_vectors.append(a)

    # Finding the orthogonal matrix
    P = Matrix(normalized_vectors).T

    # Canonical form finding
    pta = (P.T).multiply(coeff_matrix)
    C = pta.multiply(P)

    C1 = np.array(C)

    first = X1 @ C1
    can_form = first @ X2

    result = []
    for i in range(vars):
        if i == vars - 1:
            result.append(can_form[i][i])
        else:
            result.append(can_form[i][i])

    return result

vars = int(input("Enter the number of variables: "))
if vars == 2:
    x, y = symbols('x y')
elif vars == 3:
    x, y, z = symbols('x y z')

if vars == 2:
    coeff_x2 = int(input("Enter the coefficient of x^2: "))
    coeff_y2 = int(input("Enter the coefficient of y^2: "))
    coeff_xy = int(input("Enter the coefficient of xy: "))
    coeff_matrix = Matrix([[coeff_x2, Rational(coeff_xy, 2)], [Rational(coeff_xy, 2), coeff_y2]])

elif vars == 3:
    coeff_x2 = int(input("Enter the coefficient of x^2: "))
    coeff_xy = int(input("Enter the coefficient of xy: "))
    coeff_y2 = int(input("Enter the coefficient of y^2: "))
    coeff_xz = int(input("Enter the coefficient of xz: "))
    coeff_yz = int(input("Enter the coefficient of yz: "))
    coeff_z2 = int(input("Enter the coefficient of z^2: "))
    coeff_matrix = Matrix([[coeff_x2, Rational(coeff_xy, 2), Rational(coeff_xz, 2)],
                            [Rational(coeff_xy, 2), coeff_y2, Rational(coeff_yz, 2)],
                            [Rational(coeff_xz, 2), Rational(coeff_yz, 2), coeff_z2]])

canonical_form = find_canonical_form(vars, coeff_matrix)

print("\nCanonical Form:")
for i in range(vars):
    if i == vars - 1:
        print(canonical_form[i])
    else:
        print("{0} + ".format(canonical_form[i]), end=' ')